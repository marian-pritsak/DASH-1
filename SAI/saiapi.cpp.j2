#include <mutex>
#include <unordered_map>
#include <atomic>
#include <limits>
#include <stdint.h>
#include <PI/pi.h>
#include <grpcpp/grpcpp.h>
#include "p4/v1/p4runtime.grpc.pb.h"
#include "saiexperimentaldash.h"
#include "saitypes.h"
#include <fstream>
#include <google/protobuf/text_format.h>
#include <google/rpc/code.pb.h>

#if __APPLE__
#include <net/ethernet.h>
#else
#include <netinet/ether.h>
#include <netinet/in.h>
#endif

#define LOG(x) std::cerr<<x

using namespace std;

std::shared_ptr<grpc::Channel> _grpcChannel;
const grpc::string _grpcTarget = "localhost:9876";
static int deviceId;
static unordered_map<sai_object_id_t, p4::v1::TableEntry *> tableEntryMap;
static std::mutex tableLock;
static atomic<sai_object_id_t> nextId;
static std::unique_ptr<p4::v1::P4Runtime::Stub> stub;

template<typename T>
void booldataSetVal(const sai_attribute_value_t &value, T &t, int bits = 8){
    assert(bits <= 8);
    t->set_value(const_cast<bool*>(&value.booldata), 1);
}

template<typename T>
void booldataSetVal(const bool &value, T &t, int bits = 8){
    assert(bits <= 8);
    t->set_value(const_cast<bool*>(&value), 1);
}

template<typename T>
void u8SetVal(const sai_attribute_value_t &value, T &t, int bits = 8){
    assert(bits <= 8);
    t->set_value(const_cast<uint8_t*>(&value.u8), 1);
}

template<typename T>
void u8SetVal(const sai_uint8_t &value, T &t, int bits = 8){
    assert(bits <= 8);
    t->set_value(const_cast<uint8_t*>(&value), 1);
}

template<typename T>
void u16SetVal(const sai_attribute_value_t &value, T &t, int bits = 16){
    assert(bits <= 16);
    uint16_t val = value.u16;
    val = htons(val);
    t->set_value(&val, 2);}

template<typename T>
void u16SetVal(const sai_uint16_t &value, T &t, int bits = 16){
    assert(bits <= 16);
    uint16_t val = value;
    val = htons(val);
    t->set_value(&val, 2);
}

template<typename T>
void u32SetVal(const sai_attribute_value_t &value, T &t, int bits = 32){
    assert(bits <= 32);
    uint32_t val = value.u32;
    val = htons(val);
    val = val >> (32 - bits);
    int bytes = (bits + 7) / 8;
    t->set_value(&val, bytes);
}

template<typename T>
void u32SetVal(const sai_uint32_t &value, T &t, int bits = 32){
    assert(bits <= 32);
    uint32_t val = value;
    val = htons(val);
    val = val >> (32 - bits);
    int bytes = (bits + 7) / 8;
    t->set_value(&val, bytes);
}

template<typename T>
void u64SetVal(const sai_attribute_value_t &value, T &t, int bits = 64){
    assert(bits <= 64);
    uint64_t val = value.u64;
    if (*reinterpret_cast<const char*>("\0\x01") == 0) { // Little Endian
        const uint32_t high_part = htonl(static_cast<uint32_t>(val >> 32));
        const uint32_t low_part = htonl(static_cast<uint32_t>(val & 0xFFFFFFFFLL));
        val = (static_cast<uint64_t>(low_part) << 32) | high_part;
        val = val >> (64-bits);
    }
    int bytes = (bits + 7) / 8;
    t->set_value(&val, bytes);}

template<typename T>
void u64SetVal(const sai_uint64_t &value, T &t, int bits = 64) {
    assert(bits <= 64);
    uint64_t val = value;
    if (*reinterpret_cast<const char*>("\0\x01") == 0) { // Little Endian
        const uint32_t high_part = htonl(static_cast<uint32_t>(val >> 32));
        const uint32_t low_part = htonl(static_cast<uint32_t>(val & 0xFFFFFFFFLL));
        val = (static_cast<uint64_t>(low_part) << 32) | high_part;
        val = val >> (64-bits);
    }
    int bytes = (bits + 7) / 8;
    t->set_value(&val, bytes);
}

template<typename T>
void ipaddrSetVal(const sai_attribute_value_t &value, T &t, int bits = -1){
    ipaddrSetVal(value.ipaddr, t);
}

template<typename T>
void ipaddrSetVal(const sai_ip_address_t &value, T &t, int bits = -1){
    switch(value.addr_family) {
        case SAI_IP_ADDR_FAMILY_IPV4: {
            uint32_t val = value.addr.ip4;
            val = htonl(val);
            t->set_value(&val, 4);
        }
        break;
        case SAI_IP_ADDR_FAMILY_IPV6: {
            t->set_value(const_cast<uint8_t*>(&value.addr.ip6[0]), 16);
        }
        break;
        default: assert(0 && "unrecognzed value.ipaddr.addr_family");            
    }
}

template<typename T>
void macSetVal(const sai_attribute_value_t &value, T &t, int bits = -1){
    t->set_value(const_cast<uint8_t*>(&value.mac[0]), 6);
}

template<typename T>
void macSetVal(const sai_mac_t &value, T &t, int bits = -1){
    t->set_value(const_cast<uint8_t*>(&value[0]), 6);
}

int leadingNonZeroBits(const uint32_t ipv4) {
    auto firstSetBit  = __builtin_ffs(ipv4);
    if (0==firstSetBit) {
        return 0;
    }
    return 33 -  firstSetBit;
}

int leadingNonZeroBits(const sai_ip6_t ipv6) {
    int trailingZeros = 0;
    for (int i = 0; i < 16; i+=4) {
        auto num = static_cast<uint32_t>(ipv6[i]) +  
        (static_cast<uint32_t>(ipv6[i+1]) << 8) + 
        (static_cast<uint32_t>(ipv6[i+2]) << 16) + 
        (static_cast<uint32_t>(ipv6[i+3]) << 24);
        auto firstSetBit  = leadingNonZeroBits(num);
        if (firstSetBit > 0) {
            return 129-trailingZeros-firstSetBit;
        }
        trailingZeros += 32;
    }
    return 0;
}

template<typename T>
void ipPrefixSetVal(const sai_attribute_value_t &value, T &t, int bits = -1){
    ipPrefixSetVal(value.ipprefix, t);
}

template<typename T>
void ipPrefixSetVal(const sai_ip_prefix_t &value, T &t, int bits = -1){
    switch(value.addr_family) {
        case SAI_IP_ADDR_FAMILY_IPV4: {
            uint32_t val = value.addr.ip4;
            val = htonl(val);
            t->set_value(&val, 4);
            t->set_prefix_len(leadingNonZeroBits(value.addr.ip4));
        }
        break;
        case SAI_IP_ADDR_FAMILY_IPV6: {
            t->set_value(const_cast<uint8_t*>(&value.addr.ip6[0]), 16);
            t->set_prefix_len(leadingNonZeroBits(value.addr.ip6));
        }
        break;
        default: assert(0 && "unrecognzed value.ipaddr.addr_family");            
    }
}

template<typename T>
void u8listSetVal(const sai_attribute_value_t &value, T &t, int bits = -1){
    assert (0 && "NYI");
}

template<typename T>
void u16listVal(const sai_attribute_value_t &value, T &t, int bits = -1){
    assert (0 && "NYI");
}

template<typename T>
void u32listSetVal(const sai_attribute_value_t &value, T &t, int bits = -1){
    assert (0 && "NYI");
}

template<typename T>
void u64listSetVal(const sai_attribute_value_t &value, T &t, int bits = -1){
    assert (0 && "NYI");
}

template<typename T>
void ipaddrlistSetVal(const sai_attribute_value_t &value, T &t, int bits = -1){
    assert (0 && "NYI");
}

template<typename T>
void u8rangelistSetVal(const sai_attribute_value_t &value, T &t, int bits = -1){
    assert (0 && "NYI");
}

template<typename T>
void u16rangelistVal(const sai_attribute_value_t &value, T &t, int bits = -1){
    assert (0 && "NYI");
}

template<typename T>
void u32rangelistSetVal(const sai_attribute_value_t &value, T &t, int bits = -1){
    assert (0 && "NYI");
}

template<typename T>
void u64rangelistSetVal(const sai_attribute_value_t &value, T &t, int bits = -1){
    assert (0 && "NYI");
}

template<typename T>
void ipaddrrangelistSetVal(const sai_attribute_value_t &value, T &t, int bits = -1){
    assert (0 && "NYI");
}

__attribute__((constructor))
static void Init() {
    nextId = 0;
    const grpc::string _grpcTarget = "0.0.0.0:9559";
    char test_json[] = "/etc/dash/sirius_pipeline.json";
    char test_proto_json[] = "/etc/dash/sirius_pipeline_p4rt.txt";
    int dev_id = 0;

    auto p4info = parse_p4info(test_proto_json);

    auto set_election_id = [](p4::v1::Uint128 *election_id) {
        election_id->set_high(0);
        election_id->set_low(1);
    };

    grpc::ClientContext stream_context;
    _grpcChannel = grpc::CreateChannel(_grpcTarget, grpc::InsecureChannelCredentials());
    stub = p4::v1::P4Runtime::NewStub(_grpcChannel);
    auto stream = stub->StreamChannel(&stream_context);
    {
        p4::v1::StreamMessageRequest request;
        auto arbitration = request.mutable_arbitration();
        arbitration->set_device_id(dev_id);
        set_election_id(arbitration->mutable_election_id());
        stream->Write(request);
        p4::v1::StreamMessageResponse response;
        stream->Read(&response);
        assert(response.update_case() == p4::v1::StreamMessageResponse::kArbitration);
        assert(response.arbitration().status().code() == ::google::rpc::Code::OK);
    }
    {
        p4::v1::SetForwardingPipelineConfigRequest request;
        request.set_device_id(dev_id);
        request.set_action(
                p4::v1::SetForwardingPipelineConfigRequest_Action_VERIFY_AND_COMMIT);
        set_election_id(request.mutable_election_id());
        auto config = request.mutable_config();
        config->set_allocated_p4info(&p4info);
        std::ifstream istream(test_json);
        config->mutable_p4_device_config()->assign(
                (std::istreambuf_iterator<char>(istream)),
                 std::istreambuf_iterator<char>());

        p4::v1::SetForwardingPipelineConfigResponse rep;
        grpc::ClientContext context;
        auto status = stub->SetForwardingPipelineConfig(
                &context, request, &rep);
        assert(status.ok());
        config->release_p4info();
    }
}

static inline int GetDeviceId() {
    return deviceId;
}

static inline grpc::StatusCode MutateTableEntry(p4::v1::TableEntry *entry, p4::v1::Update_Type updateType) {
    p4::v1::WriteRequest request;
    request.set_device_id(GetDeviceId());
    auto update = request.add_updates();
    update->set_type(updateType);
    auto entity = update->mutable_entity();
    entity->set_allocated_table_entry(entry);
    
    p4::v1::WriteResponse rep;
    grpc::ClientContext context;
    grpc::Status status = stub->Write(&context, request, &rep);
    if (status.ok()) {
        LOG("GRPC call Write::add_one_entry OK: ");
    }
    else {
        LOG("GRPC ERROR["<< status.error_code() <<"]: " << status.error_message() << ", " << status.error_details());
        LOG("GRPC call Write::add_one_entry ERROR: " << std::endl << entry->ShortDebugString());
    }
    //MILIND?? What is this? reference release? memory release?
    entity->release_table_entry();
    return status.error_code();
}

static inline bool InsertInTable(p4::v1::TableEntry *entry, sai_object_id_t *objId) {
    auto retCode = MutateTableEntry(entry, p4::v1::Update_Type_INSERT);
    if (grpc::StatusCode::OK != retCode) {
        delete entry;
        return false;
    }

    tableLock.lock();
    *objId = nextId++;
    tableEntryMap[*objId] = entry;
    tableLock.unlock();
    return true;
}

static inline bool RemoveFromTable(sai_object_id_t id) {
    tableLock.lock();
    auto itr = tableEntryMap.find(id);
    if (itr == tableEntryMap.end()) {
        tableLock.unlock();
        LOG("id: " << id << " not present in the table for deletion!" <<endl);
        return false;
    }

    auto entry = itr->second;
    auto retCode = MutateTableEntry(entry, p4::v1::Update_Type_DELETE);
    if (grpc::StatusCode::OK != retCode) {
        tableLock.unlock();
        return false;
    }

    tableEntryMap.erase(itr);
    tableLock.unlock();
    delete entry;
    return true;
}

{% for table in tables %}

{% if table.is_object == 'true' %}
sai_status_t sai_create_{{ table.name }}(
        _Out_ sai_object_id_t *{{ table.name }}_id,
        _In_ sai_object_id_t switch_id,
        _In_ uint32_t attr_count,
        _In_ const sai_attribute_t *attr_list) { 
    p4::v1::TableEntry * matchActionEntry = new p4::v1::TableEntry();
    pi_p4_id_t tableId = {{table.id}};
        // There shall be one and only one action_type
    auto entry = matchActionEntry->mutable_action();
    auto action = entry->mutable_action();
    auto expectedParams = 0;
    auto matchedParams = 0;

    // Search the action 
    pi_p4_id_t actionId;

    matchActionEntry->set_table_id(tableId);

    auto keyStart = SAI_{{ table.name | upper }}_ATTR_KEY_START;
    auto keyEnd = SAI_{{ table.name | upper }}_ATTR_KEY_END;
    for (uint32_t i = 0; i < attr_count; i++) {
        if ( (attr_list[i].id < keyStart) || ( keyEnd < attr_list[i].id )) {
            continue;
        }
        switch(attr_list[i].id) {
            default: 
                assert(0 && "should never reach here");
                goto ErrRet;
            {% for key in table['keys'] %}
            case SAI_{{ table.name | upper }}_ATTR_{{ key.sai_key_name | upper }}: {
                auto mf = matchActionEntry->add_match();
                mf->set_field_id({{key.id}});
                {% if key.match_type == 'exact' %}
                auto mf_exact = mf->mutable_exact();
                {{key.sai_key_field}}SetVal(attr_list[i].value, mf_exact, {{key.bitwidth}});
                {% elif key.match_type == 'lpm' %}
                auto mf_lpm = mf->mutable_lpm();
                {{key.sai_lpm_field}}SetVal(attr_list[i].value, mf_lpm, {{key.bitwidth}});
                {% elif key.match_type == 'list' %}
                assert(0 && "mutable_list is not supported");
                goto ErrRet;
                // auto mf1_list = mf1->mutable_xxx();
                //{{key.sai_list_field}}SetVal(attr_list[i].value, mf1_list, {{key.bitwidth}});
                {% elif key.match_type == 'range_list' %}
                goto ErrRet;
                assert(0 && "range_list is not supported");
                // auto mf1_list = mf1->mutable_xxx();
                //{{key.sai_range_list_field}}SetVal(attr_list[i].value, mf1_list, {{key.bitwidth}});
                {% endif %}
                // TODO: if it is ternary, need to set the mask
                break;
            }
            {% endfor %}
        }
    }


    // If there is only one action, simply set it.
    // Else, search in the attrs.
    {% if table.actions|length == 1 %}
    {% for action in table.actions %}
    actionId = {{action.id}}; // SAI_{{ table.name | upper }}_ACTION_{{ action.name | upper }}
    expectedParams = {{ action.params|length }};
    {% endfor %}
    {% else %}
    // Search the action 
    for (uint32_t i = 0; i < attr_count; i++) {
        auto actionStart = SAI_{{ table.name | upper }}_ATTR_ACTION_START;
        auto actionEnd = SAI_{{ table.name | upper }}_ATTR_ACTION_END;

        if ( (attr_list[i].id < actionStart) || (  actionEnd < attr_list[i].id)) {
            continue;
        }
        switch(attr_list[i].value.s32) {
            default: 
                assert(0 && "should never reach here"); 
                goto ErrRet;
            {% for action in table.actions %}
            case SAI_{{ table.name | upper }}_ACTION_{{ action.name | upper }}: {
                actionId = {{action.id}}; 
                expectedParams = {{ action.params|length }};
                break;
            }
            {% endfor %}
        }
        // only one action
        break;
    }
    {% endif %}
    action->set_action_id(actionId);

    for (uint32_t i = 0; i < attr_count; i++) {
        auto paramStart = SAI_{{ table.name | upper }}_ATTR_PARAM_START;
        auto paramEnd = SAI_{{ table.name | upper }}_ATTR_PARAM_END;

        if ( (attr_list[i].id < paramStart ) || ( paramEnd < attr_list[i].id)) {
            continue;
        }
        switch(attr_list[i].id) {
            default: 
                assert(0 && "should never reach here"); 
                goto ErrRet;
            {% for action in table.actions %}
            {% for param in action.params %}
            case SAI_{{ table.name | upper }}_ATTR_{{ param.name | upper }}: {
                auto param = action->add_params();
                param->set_param_id({{param.id}});
                {{param.field}}SetVal(attr_list[i].value, param, {{param.bitwidth}});
                matchedParams++;
                break;
            }
            {% endfor %}
            {% endfor %}
        }
    }
    
    assert((matchedParams == expectedParams)); 

    if (matchedParams != expectedParams) {
        goto ErrRet;
    }
    // TODO: ternaly needs to set priority
    uint64_t objId;
    if (true == InsertInTable(matchActionEntry, &objId)) {
        *{{ table.name }}_id = objId;
        return 0;
    }
ErrRet:
    delete matchActionEntry;
    return -1;
}

sai_status_t sai_remove_{{ table.name }}(_In_ sai_object_id_t {{ table.name }}_id) {
    if (RemoveFromTable({{ table.name }}_id)) {
        return 0;
    }
    return -1;
}

sai_status_t sai_set_{{ table.name }}_attribute (
        _In_ sai_object_id_t {{ table.name }}_id,
        _In_ const sai_attribute_t *attr) {
    assert(0 && "sai_set_{{ table.name }}_attribute NYI");
    return -1;
}

sai_status_t sai_get_{{ table.name }}_attribute(
        _In_ sai_object_id_t {{ table.name }}_id,
        _In_ uint32_t attr_count,
        _Inout_ sai_attribute_t *attr_list) {
    assert(0 && "sai_get_{{ table.name }}_attribute NYI");
    return -1;
}
{% else %}
sai_status_t sai_create_{{ table.name }}(
        _In_ const sai_{{ table.name }}_t *{{ table.name }},
        _In_ uint32_t attr_count,
        _In_ const sai_attribute_t *attr_list) { 
    p4::v1::TableEntry * matchActionEntry = new p4::v1::TableEntry();
    pi_p4_id_t tableId = {{table.id}};
    matchActionEntry->set_table_id(tableId);
    auto tableEntry = {{ table.name }};
    // There shall be one and only one action_type
    auto entry = matchActionEntry->mutable_action();
    auto action = entry->mutable_action();
    auto expectedParams = 0;
    auto matchedParams = 0;
    pi_p4_id_t actionId;
    grpc::StatusCode retCode;

    {% for key in table['keys'] %}
    {
        auto mf = matchActionEntry->add_match();
        mf->set_field_id({{key.id}});
        {% if key.match_type == 'exact' %}
        auto mf_exact = mf->mutable_exact();
        {{key.sai_key_field}}SetVal(tableEntry->{{ key.sai_key_name }}, mf_exact, {{key.bitwidth}});
        {% elif key.match_type == 'lpm' %}
        auto mf_lpm = mf->mutable_lpm();
        {{key.sai_lpm_field}}SetVal(tableEntry->{{ key.sai_key_name }}, mf_lpm, {{key.bitwidth}});
        {% elif key.match_type == 'list' %}
        assert(0 && "mutable_list is not supported");
        goto ErrRet;
        // auto mf1_list = mf1->mutable_xxx();
        //{{key.sai_list_field}}SetVal(attr_list[i].value, mf1_list, {{key.bitwidth}});
        {% elif key.match_type == 'range_list' %}
        assert(0 && "range_list is not supported");
        goto ErrRet;
        // auto mf1_list = mf1->mutable_xxx();
        //{{key.sai_range_list_field}}SetVal(attr_list[i].value, mf1_list, {{key.bitwidth}});
        {% endif %}
        // TODO: if it is ternary, need to set the mask
    }
    {% endfor %}


    {% if table.actions|length == 1 %}
    {% for action in table.actions %}
    actionId = {{action.id}}; // SAI_{{ table.name | upper }}_ACTION_{{ action.name | upper }}
    expectedParams = {{ action.params|length }};
    {% endfor %}
    {% else %}
    // Search the action 
    for (uint32_t i = 0; i < attr_count; i++) {
        auto actionStart = SAI_{{ table.name | upper }}_ATTR_ACTION_START;
        auto actionEnd = SAI_{{ table.name | upper }}_ATTR_ACTION_END;

        if ( (attr_list[i].id < actionStart ) || ( actionEnd < attr_list[i].id)) {
            continue;
        }
        switch(attr_list[i].value.s32) {
            default: 
                assert(0 && "should never reach here"); 
                goto ErrRet;
            {% for action in table.actions %}
            case SAI_{{ table.name | upper }}_ACTION_{{ action.name | upper }}: {
                actionId = {{action.id}}; 
                expectedParams = {{ action.params|length }};
                break;
            }
            {% endfor %}
        }
        // only one action
        break;
    }
    {% endif %}
    action->set_action_id(actionId);

    for (uint32_t i = 0; i < attr_count; i++) {
        auto paramStart = SAI_{{ table.name | upper }}_ATTR_PARAM_START;
        auto paramEnd = SAI_{{ table.name | upper }}_ATTR_PARAM_END;

        if ( (attr_list[i].id < paramStart) || ( paramEnd < attr_list[i].id)) {
            continue;
        }

        switch(attr_list[i].id) {
            default: 
                assert(0 && "should never reach here"); 
                goto ErrRet;
            {% for action in table.actions %}
            {% for param in action.params %}
            case SAI_{{ table.name | upper }}_ATTR_{{ param.name | upper }}: {
                auto param = action->add_params();
                param->set_param_id({{param.id}});
                {{param.field}}SetVal(attr_list[i].value, param, {{param.bitwidth}});
                matchedParams++;
                break;
            }
            {% endfor %}
            {% endfor %}
        }
    }
    
    assert((matchedParams == expectedParams)); 

    if (matchedParams != expectedParams) {
        goto ErrRet;
    }
    // TODO: ternaly needs to set priority
    retCode = MutateTableEntry(matchActionEntry, p4::v1::Update_Type_INSERT);
    if (grpc::StatusCode::OK == retCode) {
        delete matchActionEntry;
        return 0;
    }
ErrRet:
    delete matchActionEntry;
    return -1;
}

sai_status_t sai_remove_{{ table.name }}(
        _In_ const sai_{{ table.name }}_t *{{ table.name }}) { 
    p4::v1::TableEntry * matchActionEntry = new p4::v1::TableEntry();
    pi_p4_id_t tableId = {{table.id}};
    matchActionEntry->set_table_id(tableId);
    auto tableEntry =  {{ table.name }};
    grpc::StatusCode retCode;

    {% for key in table['keys'] %}
    {
        auto mf = matchActionEntry->add_match();
        mf->set_field_id({{key.id}});
        {% if key.match_type == 'exact' %}
        auto mf_exact = mf->mutable_exact();
        {{key.sai_key_field}}SetVal(tableEntry->{{ key.sai_key_name }}, mf_exact, {{key.bitwidth}});
        {% elif key.match_type == 'lpm' %}
        auto mf_lpm = mf->mutable_lpm();
        {{key.sai_lpm_field}}SetVal(tableEntry->{{ key.sai_key_name }}, mf_lpm, {{key.bitwidth}});
        {% elif key.match_type == 'list' %}
        assert(0 && "mutable_list is not supported");
        goto ErrRet;
        // auto mf1_list = mf1->mutable_xxx();
        //{{key.sai_list_field}}SetVal(attr_list[i].value, mf1_list, {{key.bitwidth}});
        {% elif key.match_type == 'range_list' %}
        assert(0 && "range_list is not supported");
        goto ErrRet;
        // auto mf1_list = mf1->mutable_xxx();
        //{{key.sai_range_list_field}}SetVal(attr_list[i].value, mf1_list, {{key.bitwidth}});
        {% endif %}
        // TODO: if it is ternary, need to set the mask
    }
    {% endfor %}

    retCode = MutateTableEntry(matchActionEntry, p4::v1::Update_Type_DELETE);
    if (grpc::StatusCode::OK != retCode) {
        delete matchActionEntry;
        return 0;
    }

ErrRet:

    delete matchActionEntry;
    return -1;
}

sai_status_t sai_set_{{ table.name }}_attribute(
        _In_ const sai_{{ table.name }}_t *{{ table.name }},
        _In_ const sai_attribute_t *attr) {
            assert(0 && "sai_set_{{ table.name }}_attribute NYI");
            return -1;
}

sai_status_t sai_get_{{ table.name }}_attribute(
        _In_ const sai_{{ table.name }}_t *{{ table.name }},
        _In_ uint32_t attr_count,
        _Inout_ sai_attribute_t *attr_list) {
            assert(0 && "sai_get_{{ table.name }}_attribute NYI");
            return -1;
}
{% endif %}
{% endfor %}

static sai_{{ app_name }}_api_t sai_{{app_name }}_api_impl = {
{% for table in tables %}
    .create_{{ table.name }} =  sai_create_{{ table.name }},
    .remove_{{ table.name }} = sai_remove_{{ table.name }},
    .set_{{ table.name }}_attribute = sai_set_{{ table.name }}_attribute,
    .get_{{ table.name }}_attribute = sai_get_{{ table.name }}_attribute,
{% endfor %}
};